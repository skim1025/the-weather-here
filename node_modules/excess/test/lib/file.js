// Generated by CoffeeScript 1.7.1

/*
    xs_file.coffee

    Copyright (C) 2013, 2014, Connected Sets

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

(function() {
  var check, clone, expect, utils, xs;

  if (typeof require !== "undefined" && require !== null) {
    utils = require('./tests_utils.js');
  }

  expect = this.expect || utils.expect;

  clone = this.clone || utils.clone;

  check = this.check || utils.check;

  xs = this.xs || utils.xs;

  if (typeof require !== "undefined" && require !== null) {
    require('../../lib/filter.js');
    require('../../lib/server/file.js');
  }

  describe('file', function() {
    describe('require_resolve():', function() {
      var modules, resolve, resolved;
      modules = xs.set([
        {
          id: 1,
          name: 'node-uuid/uuid.js'
        }
      ], {
        key: ['id', 'name']
      });
      resolve = modules.require_resolve();
      resolved = resolve.trace('uuid.js');
      it('should resolve node-uuid/uuid.js', function(done) {
        return resolved._fetch_all(function(values) {
          return check(done, function() {
            var name, path, uuid;
            expect(values.length).to.be.eql(1);
            uuid = values[0];
            name = uuid.name;
            path = uuid.path.replace(/\\/g, '/');
            expect(name).to.be.eql('node-uuid/uuid.js');
            expect(path.substr(path.length - name.length)).to.be.eql(name);
            return expect(uuid.uri).to.be.eql('/node_modules/node-uuid/uuid.js');
          });
        });
      });
      return it('should allow to remove a module', function(done) {
        modules._remove([
          {
            id: 1,
            name: 'node-uuid/uuid.js'
          }
        ]);
        return resolved._fetch_all(function(values) {
          return check(done, function() {
            return expect(values.length).to.be.eql(0);
          });
        });
      });
    });
    describe('configuration():', function() {
      return it('should read a confirugation file in fixtures/config.json', function(done) {
        var configuration;
        configuration = xs.configuration({
          filepath: '../fixtures/file/config.json',
          base_directory: __dirname,
          key: ['module']
        });
        return configuration._on('complete', function() {
          return configuration._fetch_all(function(values) {
            return check(done, function() {
              return expect(values).to.be.eql([
                {
                  flow: "configuration",
                  module: "nodemailer",
                  transport: "sendmail",
                  transport_options: {}
                }, {
                  flow: "configuration",
                  pipelet: "passport_strategy",
                  name: "twitter",
                  credentials: {
                    key: "***",
                    secret: "---"
                  }
                }, {
                  flow: "configuration",
                  pipelet: "passport_strategy",
                  name: "facebook",
                  credentials: {
                    key: "***",
                    secret: "---"
                  }
                }
              ]);
            });
          });
        });
      });
    });
    return describe('watch_directories():', function() {
      var css, directories, directories_source, entries, entry_sorter, expected_directories, get_entry_static_attributes, html, javascript;
      directories_source = xs.set([
        {
          path: 'directories'
        }, {
          path: 'directories'
        }, {
          path: 'directories'
        }
      ], {
        key: ['path']
      }).union([]);
      entries = directories_source.watch_directories({
        base_directory: 'test/fixtures/file'
      });
      directories = entries.filter([
        {
          type: 'directory'
        }
      ]).trace('directories');
      directories_source._add_source(directories);
      expected_directories = ['directories', 'directories/css', 'directories/html', 'directories/lib', 'directories/lib/client', 'directories/lib/client/index', 'directories/lib/server', 'directories/lib/server/index'];
      css = entries.filter([
        {
          type: 'file',
          extension: 'css'
        }
      ]).trace('css files').set();
      html = entries.filter([
        {
          type: 'file',
          extension: 'html'
        }
      ]).trace('html files').set();
      javascript = entries.filter([
        {
          type: 'file',
          extension: 'js'
        }
      ]).set();
      get_entry_static_attributes = function(e) {
        return {
          path: e.path,
          type: e.type,
          extension: e.extension,
          depth: e.depth
        };
      };
      entry_sorter = function(a, b) {
        if (a.path < b.path) {
          return -1;
        } else {
          return a.path > b.path;
        }
      };
      it('should have many directories', function() {
        return expect(Object.keys(entries._directories).sort()).to.be.eql(expected_directories);
      });
      it('"directories" directory should have a count of 3', function() {
        return expect(entries._directories['directories'].count).to.be.eql(3);
      });
      it('"directories/css" directory should have a count of 1', function() {
        return expect(entries._directories['directories/css'].count).to.be.eql(1);
      });
      it('"directories/lib/client/index" directory should have a count of 1', function() {
        return expect(entries._directories['directories/lib/client/index'].count).to.be.eql(1);
      });
      it('should have javascript files', function(done) {
        return javascript._fetch_all(function(values) {
          return check(done, function() {
            return expect(values.map(get_entry_static_attributes).sort(entry_sorter)).to.be.eql([
              {
                "path": "directories/lib/client/index/start.js",
                "type": "file",
                "extension": "js",
                "depth": 4
              }, {
                "path": "directories/lib/server/index/models.js",
                "type": "file",
                "extension": "js",
                "depth": 4
              }
            ]);
          });
        });
      });
      it('should have css files', function(done) {
        return css._fetch_all(function(values) {
          return check(done, function() {
            return expect(values.map(get_entry_static_attributes).sort(entry_sorter)).to.be.eql([
              {
                "path": "directories/css/index.css",
                "type": "file",
                "extension": "css",
                "depth": 2
              }
            ]);
          });
        });
      });
      it('should have an html file', function(done) {
        return html._fetch_all(function(values) {
          return check(done, function() {
            return expect(values.map(get_entry_static_attributes).sort(entry_sorter)).to.be.eql([
              {
                "path": "directories/html/index.html",
                "type": "file",
                "extension": "html",
                "depth": 2
              }
            ]);
          });
        });
      });
      it('should have 11 entries', function(done) {
        return entries._fetch_all(function(values) {
          return check(done, function() {
            return expect(values.length).to.be(11);
          });
        });
      });
      it('should many directories at depths 1, and 2', function(done) {
        return directories._fetch_all(function(values) {
          return check(done, function() {
            return expect(values.map(get_entry_static_attributes).sort(entry_sorter)).to.be.eql([
              {
                "path": "directories/css",
                "type": "directory",
                "extension": "",
                "depth": 1
              }, {
                "path": "directories/html",
                "type": "directory",
                "extension": "",
                "depth": 1
              }, {
                path: 'directories/lib',
                type: 'directory',
                extension: '',
                depth: 1
              }, {
                path: 'directories/lib/client',
                type: 'directory',
                extension: '',
                depth: 2
              }, {
                path: 'directories/lib/client/index',
                type: 'directory',
                extension: '',
                depth: 3
              }, {
                "path": "directories/lib/server",
                "type": "directory",
                "extension": "",
                "depth": 2
              }, {
                "path": "directories/lib/server/index",
                "type": "directory",
                "extension": "",
                "depth": 3
              }
            ]);
          });
        });
      });
      it('should not remove "directories" directory after removing 2 extra path from directories_source', function() {
        entries._remove([
          {
            path: 'directories'
          }, {
            path: 'directories'
          }
        ]);
        return expect(entries._directories['directories'].count).to.be.eql(1);
      });
      it('should still have many directories', function() {
        return expect(Object.keys(entries._directories).sort()).to.be.eql(expected_directories);
      });
      it('should remove both directories after removing the "directories" directory', function() {
        entries._remove([
          {
            path: 'directories'
          }
        ]);
        return expect(Object.keys(entries._directories)).to.be.eql([]);
      });
      it('should have no directory left', function(done) {
        return directories._fetch_all(function(values) {
          return check(done, function() {
            return expect(values).to.be.eql([]);
          });
        });
      });
      it('should have no css files left', function(done) {
        return css._fetch_all(function(values) {
          return check(done, function() {
            return expect(values).to.be.eql([]);
          });
        });
      });
      it('should have no html files left', function(done) {
        return html._fetch_all(function(values) {
          return check(done, function() {
            return expect(values).to.be.eql([]);
          });
        });
      });
      it('should have no javascript files left', function(done) {
        return javascript._fetch_all(function(values) {
          return check(done, function() {
            return expect(values).to.be.eql([]);
          });
        });
      });
      it('should have no entries left', function(done) {
        return entries._fetch_all(function(values) {
          return check(done, function() {
            return expect(values).to.be.eql([]);
          });
        });
      });
      it('should not throw after attempting to remove extra directory', function() {
        entries._remove([
          {
            path: 'directories'
          }
        ]);
        return expect(Object.keys(entries._directories)).to.be.eql([]);
      });
      return it('from_empty_directory_path should emit three entries with no leading "/"', function(done) {
        var from_empty_directory_path;
        from_empty_directory_path = xs.set([
          {
            path: ''
          }
        ], {
          key: ['path']
        }).watch_directories({
          base_directory: 'test/fixtures/file/directories',
          name: 'from_empty_directory_path'
        });
        return from_empty_directory_path._on('complete', function() {
          return from_empty_directory_path._fetch_all(function(values) {
            return check(done, function() {
              return expect(values.map(get_entry_static_attributes).sort(entry_sorter)).to.be.eql([
                {
                  "path": "css",
                  "type": "directory",
                  "extension": "",
                  "depth": 1
                }, {
                  "path": "html",
                  "type": "directory",
                  "extension": "",
                  "depth": 1
                }, {
                  "path": "lib",
                  "type": "directory",
                  "extension": "",
                  "depth": 1
                }
              ]);
            });
          });
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=file.map
